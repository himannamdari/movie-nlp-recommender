# -*- coding: utf-8 -*-
"""movie-nlp-recommender.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RGKgjZRGGWE4V3jFSDYHapqaAL1E5ys0

### STEP 1 â€“ Install / check libraries (Colab)
"""

import sys

import numpy as np
import pandas as pd
import sklearn

print("Python:", sys.version)
print("NumPy:", np.__version__)
print("pandas:", pd.__version__)
print("scikit-learn:", sklearn.__version__)

"""###STEP 2 â€“ Download the MovieLens dataset in Colab

"""

!wget https://files.grouplens.org/datasets/movielens/ml-latest-small.zip
!unzip -o ml-latest-small.zip

"""### STEP 3 â€“ Load movies.csv with pandas"""

movies_path = "/content/ml-latest-small/movies.csv"
movies = pd.read_csv(movies_path)

movies.head(10)

movies.shape, movies.columns

"""### STEP 4 â€“ Create a combined text feature

Weâ€™ll use title + genres as our textual description of each movie.
"""

# Make a copy just to be safe (optional)
movies_df = movies.copy()

# Replace missing values in title/genres with empty string (defensive)
movies_df['title'] = movies_df['title'].fillna('')
movies_df['genres'] = movies_df['genres'].fillna('')

# Genres are like "Adventure|Animation|Children"
# Replace '|' with space so it looks more like normal text
movies_df['genres_clean'] = movies_df['genres'].str.replace('|', ' ', regex=False)

# Combine title + cleaned genres into one text field
movies_df['combined'] = movies_df['title'] + " " + movies_df['genres_clean']

movies_df[['movieId', 'title', 'genres', 'combined']].head(10)

"""### STEP 5 â€“ Vectorize using TF-IDF

Now we use TfidfVectorizer from scikit-learn.
"""

from sklearn.feature_extraction.text import TfidfVectorizer

# Initialize the vectorizer
# stop_words='english' removes common words like "the", "and"
tfidf = TfidfVectorizer(stop_words='english')

# Learn vocabulary and transform the combined text into TF-IDF matrix
tfidf_matrix = tfidf.fit_transform(movies_df['combined'])

tfidf_matrix.shape

tfidf_matrix[:1].toarray()

"""### STEP 6 â€“ Cosine similarity matrix

Concept (super short):

Each movie = TF-IDF vector
"""

from sklearn.metrics.pairwise import linear_kernel  # fast cosine for sparse matrices

# Compute cosine similarity between all pairs of movies
cosine_sim = linear_kernel(tfidf_matrix, tfidf_matrix)

cosine_sim.shape
cosine_sim[:10]

"""### STEP 7 â€“ Build a lookup from title â†’ index

We need a way to quickly go from a movie title to its row index in movies_df.
"""

# Reset index to be safe and keep a clean mapping
movies_df = movies_df.reset_index()
# Now we have a column named 'index' plus 'movieId', 'title', etc.

# Build a mapping from title to DataFrame index
# If there are duplicate titles, this keeps the LAST occurrence
title_to_index = pd.Series(movies_df.index, index=movies_df['title'].str.lower())

# Quick check for a known title (case-insensitive)
title_to_index['toy story (1995)']

"""STEP 8 â€“ Define get_recommendations(title, n=10)

Now the fun part: given a title, find similar movies by cosine similarity.
"""

def get_recommendations(title, n=10):
    """
    Given a movie title (string), return a DataFrame of the top-n most similar movies.
    """
    title_lower = title.lower()

    if title_lower not in title_to_index:
        # If exact match not found, try a partial search to help the user
        matches = movies_df[movies_df['title'].str.lower().str.contains(title_lower)]
        print(f"Title '{title}' not found as exact match.")
        if not matches.empty:
            print("Did you mean one of these?")
            print(matches['title'].head(10).to_string(index=False))
        return None

    # Get the index of the movie that matches the title
    idx = title_to_index[title_lower]

    # Get the pairwise similarity scores of all movies with that movie
    sim_scores = list(enumerate(cosine_sim[idx]))

    # Sort the movies based on similarity score
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)

    # The first result is the movie itself, so skip it
    sim_scores = sim_scores[1:n+1]

    # Get the movie indices
    movie_indices = [i[0] for i in sim_scores]
    scores = [i[1] for i in sim_scores]

    # Return titles and similarity scores as a DataFrame
    results = movies_df.iloc[movie_indices][['title', 'genres']].copy()
    results['similarity'] = scores

    return results

"""STEP 9 â€“ Test the recommender

Now letâ€™s try it with a few example movies.

"""

recommendations = get_recommendations("Notebook, The (2004)", n=3)
recommendations

def interactive_recommender():
    print("ðŸŽ¬ Movie Recommender â€“ type a title, or 'q' to quit.\n")
    while True:
        user_input = input("Enter a movie title: ").strip()
        if user_input.lower() in ['q', 'quit', 'exit']:
            print("Goodbye! ðŸ‘‹")
            break

        recs = get_recommendations(user_input, n=10)
        if recs is None:
            continue  # go back and ask again

        print("\nTop recommendations:")
        for i, row in recs.reset_index(drop=True).iterrows():
            print(f"{i+1:2d}. {row['title']}  |  {row['genres']}  (similarity: {row['similarity']:.3f})")
        print("\n" + "-"*60 + "\n")

# Run this to start the loop:
interactive_recommender()